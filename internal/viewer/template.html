<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CS2 Demo Viewer</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{background:#0d1117;color:#e6edf3;font-family:'Segoe UI',system-ui,sans-serif;display:flex;flex-direction:column;height:100vh;overflow:hidden;user-select:none}
#hdr{padding:8px 16px;background:#161b22;border-bottom:1px solid #30363d;display:flex;align-items:center;gap:12px;flex-shrink:0}
#hdr h1{font-size:15px;font-weight:600;color:#58a6ff}
#hdr-info{font-size:12px;color:#8b949e}
#main{flex:1;display:flex;overflow:hidden}
#canvas-wrap{flex:1;display:flex;align-items:center;justify-content:center;background:#0d1117;position:relative;overflow:hidden}
canvas{display:block;cursor:crosshair}
#killfeed{position:absolute;top:10px;right:10px;pointer-events:none;display:flex;flex-direction:row;gap:8px;align-items:flex-start;max-height:calc(100% - 20px)}
#feed-active,#feed-passive{display:flex;flex-direction:column;gap:4px;overflow-y:hidden}
#feed-active{width:220px}#feed-passive{width:170px}
.kf-entry{background:rgba(13,17,23,0.88);border-left:3px solid #444;border-radius:0 5px 5px 0;padding:5px 9px;font-size:12px;display:flex;flex-direction:column;gap:2px}
.kf-row1{display:flex;align-items:center;gap:6px}
.kf-row2{font-size:10px;color:#8b949e;display:flex;gap:6px}
.kf-ct{border-left-color:#4fc3f7}.kf-t{border-left-color:#ff9800}.kf-bomb{border-left-color:#ffd700}
.kf-name-atk{font-weight:700}.kf-name-vic{font-weight:700;color:#adbac7}
.kf-hs{color:#f85149;font-size:9px;background:#3d1a1a;border-radius:3px;padding:1px 3px}
.kf-weapon{color:#8b949e;font-size:11px}
.kf-dmg{color:#7ee787;font-size:10px;background:#0d2414;border-radius:3px;padding:1px 4px}
.kf-time{color:#6e7681;font-size:10px;margin-left:auto}
.kf-nade{border-left-color:#7ee787}
.kf-hit{border-left-color:#555}
#level-btn{position:absolute;top:10px;left:10px;background:#21262d;border:1px solid #30363d;color:#e6edf3;padding:5px 10px;border-radius:4px;cursor:pointer;font-size:12px}
#level-btn:hover{background:#30363d}
#level-btn.lower{background:#2ea043;border-color:#2ea043}
#tooltip{position:absolute;background:rgba(13,17,23,0.92);border:1px solid #30363d;border-radius:4px;padding:4px 8px;font-size:11px;pointer-events:none;display:none;white-space:nowrap;z-index:10}
#controls{padding:8px 16px;background:#161b22;border-top:1px solid #30363d;display:flex;align-items:center;gap:10px;flex-shrink:0;min-height:46px}
.round-nav{display:flex;align-items:center;gap:4px}
.nav-btn{background:#21262d;border:1px solid #30363d;color:#e6edf3;width:26px;height:26px;border-radius:4px;cursor:pointer;font-size:13px;display:flex;align-items:center;justify-content:center}
.nav-btn:hover{background:#30363d}
#round-lbl{font-size:12px;min-width:80px;text-align:center;color:#e6edf3}
#play-btn{background:#238636;border:none;color:#fff;padding:5px 14px;border-radius:4px;cursor:pointer;font-size:13px;font-weight:500;min-width:70px;height:28px}
#play-btn:hover{background:#2ea043}
#timeline{width:100%;accent-color:#2ea043;cursor:pointer;margin:0}
.spd-btns{display:flex;gap:3px}
.spd-btn{background:#21262d;border:1px solid #30363d;color:#8b949e;padding:3px 7px;border-radius:4px;cursor:pointer;font-size:11px}
.spd-btn:hover{background:#30363d;color:#e6edf3}
.spd-btn.active{background:#1f6feb;border-color:#1f6feb;color:#fff}
#tick-lbl{font-size:11px;color:#8b949e;min-width:90px;text-align:right}
#event-marks{position:relative;height:4px;overflow:hidden;border-radius:2px}
.ev-mark{position:absolute;top:0;width:2px;height:100%;border-radius:1px;pointer-events:none;transform:translateX(-50%)}
/* Stats panel */
#stats-panel{width:260px;background:#161b22;border-left:1px solid #30363d;overflow-y:auto;flex-shrink:0;display:none;flex-direction:column}
#stats-panel table{width:100%;border-collapse:collapse;font-size:11px}
#stats-panel th{padding:6px 8px;color:#8b949e;font-weight:500;border-bottom:1px solid #30363d;text-align:right}
#stats-panel th:first-child{text-align:left}
#stats-panel td{padding:5px 8px;border-bottom:1px solid #21262d;text-align:right;white-space:nowrap}
#stats-panel td:first-child{text-align:left;max-width:120px;overflow:hidden;text-overflow:ellipsis}
#stats-panel tr:hover td{background:rgba(255,255,255,0.04)}
.stats-hdr{padding:8px 10px;font-size:11px;font-weight:600;color:#8b949e;letter-spacing:.05em;text-transform:uppercase;border-bottom:1px solid #30363d}
</style>
</head>
<body>
<div id="hdr">
  <h1 id="map-name">—</h1>
  <span id="hdr-info"></span>
  <div style="margin-left:auto;display:flex;align-items:center;gap:14px">
    <div id="alive-ctr" style="font-size:13px;font-weight:600;letter-spacing:.03em">
      <span id="ct-alive" style="color:#4fc3f7">5</span><span style="color:#555">v</span><span id="t-alive" style="color:#ff9800">5</span>
    </div>
    <div id="timers" style="display:flex;flex-direction:column;align-items:center;gap:1px;min-width:52px">
      <div id="round-timer" style="font-size:17px;font-weight:700;color:#e6edf3;letter-spacing:.04em;font-variant-numeric:tabular-nums;line-height:1">1:55</div>
      <div id="c4-timer" style="font-size:12px;font-weight:700;color:#ffd700;letter-spacing:.04em;font-variant-numeric:tabular-nums;display:none">C4 0:40.0</div>
    </div>
    <button id="stats-btn" onclick="toggleStats()"
      style="background:#21262d;border:1px solid #30363d;color:#e6edf3;padding:4px 11px;border-radius:4px;cursor:pointer;font-size:12px">
      Stats
    </button>
    <div id="score" style="display:flex;gap:10px;font-size:13px;font-weight:600">
      <span id="ct-score" style="color:#4fc3f7">CT 0</span>
      <span style="color:#8b949e">—</span>
      <span id="t-score" style="color:#ff9800">T 0</span>
    </div>
  </div>
</div>
<div id="main">
  <div id="canvas-wrap">
    <canvas id="canvas"></canvas>
    <div id="killfeed">
      <div id="feed-passive"></div>
      <div id="feed-active"></div>
    </div>
    <div id="level-btn" style="display:none" onclick="toggleLevel()">Upper</div>
    <div id="tooltip"></div>
  </div>
  <div id="stats-panel">
    <div class="stats-hdr">Match Stats</div>
    <table>
      <thead>
        <tr>
          <th>Player</th>
          <th>K</th><th>D</th><th>HS%</th><th id="stats-dmg-hdr">DMG</th>
        </tr>
      </thead>
      <tbody id="stats-body"></tbody>
    </table>
  </div>
</div>
<div id="controls">
  <div class="round-nav">
    <button class="nav-btn" onclick="changeRound(-1)">&#9664;</button>
    <span id="round-lbl">Round 1</span>
    <button class="nav-btn" onclick="changeRound(1)">&#9654;</button>
  </div>
  <button id="play-btn" onclick="togglePlay()">&#9654; Play</button>
  <div style="flex:1;display:flex;flex-direction:column;gap:2px;min-width:0">
    <input type="range" id="timeline" min="0" max="1000" value="0" oninput="onScrub(this.value)">
    <div id="event-marks"></div>
  </div>
  <div class="spd-btns">
    <button class="spd-btn" onclick="setSpeed(0.5,this)">0.5×</button>
    <button class="spd-btn active" onclick="setSpeed(1,this)">1×</button>
    <button class="spd-btn" onclick="setSpeed(2,this)">2×</button>
    <button class="spd-btn" onclick="setSpeed(4,this)">4×</button>
    <button class="spd-btn" onclick="setSpeed(8,this)">8×</button>
  </div>
  <span id="tick-lbl"></span>
</div>

<script>
const DEMO = /*INJECT_DATA*/;

// ── Data format helpers ───────────────────────────────────────────────────────
// PlayerState array: [idx, flags, hp, x, y, z, yaw]
const PS_IDX=0, PS_FLAGS=1, PS_HP=2, PS_X=3, PS_Y=4, PS_Z=5, PS_YAW=6;
function psTeam(ps)  { return (ps[PS_FLAGS] & 2) ? 'T' : 'CT'; }
function psAlive(ps) { return !(ps[PS_FLAGS] & 1); }
function psBomb(ps)  { return !!(ps[PS_FLAGS] & 4); }

// Round time: seconds elapsed from freeze-end tick
function roundTimeFmt(round, tick) {
  if (!round || !round.fe) return '';
  const secs = Math.max(0, Math.floor((tick - round.fe) / 64));
  return Math.floor(secs / 60) + ':' + String(secs % 60).padStart(2, '0');
}

// Kill array: [tick, atkIdx, vicIdx, weapon, hs(0/1), atkX, atkY, vicX, vicY, dmg]
const K_TICK=0,K_ATK=1,K_VIC=2,K_WEP=3,K_HS=4,K_AX=5,K_AY=6,K_VX=7,K_VY=8,K_DMG=9;

// BombAction array: [tick, action, x, y, site]
const BA_TICK=0, BA_ACT=1, BA_X=2, BA_Y=3, BA_SITE=4;

// Grenade array: [startTick, endTick, type, x, y, throwerIdx]
const GR_ST=0, GR_ET=1, GR_TYPE=2, GR_X=3, GR_Y=4, GR_THROWER=5;
const GT_SMOKE=0, GT_FLASH=1, GT_HE=2, GT_MOLOTOV=3, GT_SMOKE_CT=4, GT_SMOKE_T=5;

// Shot array: [tick, playerIdx]
const SH_TICK=0, SH_PIDX=1;

// HitEvent array: [tick, atkIdx, vicIdx, dmg, weapon]
const HI_TICK=0, HI_ATK=1, HI_VIC=2, HI_DMG=3, HI_WEP=4;

// GrenadeTrail array: [startTick, endTick, type, throwerIdx, [[tickOffset,x,y],...]]
const TR_ST=0, TR_ET=1, TR_TYPE=2, TR_THROWER=3, TR_PTS=4;
const TR_PT_T=0, TR_PT_X=1, TR_PT_Y=2;

// ── Constants ─────────────────────────────────────────────────────────────────
const RADAR_SIZE        = 1024;
const SAMPLE_FPS        = 4;
const CT_COLOR          = '#4fc3f7';
const T_COLOR           = '#ff9800';
const DEAD_COLOR        = '#555';
const PLAYER_R          = 8;
const DIR_LEN           = 18;
const KILL_FLASH_TICKS  = 48;
const KILL_FEED_MAX     = 8;
const SMOKE_WORLD_R     = 170;
const MOLOTOV_WORLD_R   = 120;
const GREN_FADE_TICKS   = 64;
const SHOOT_FLASH_TICKS = 12;
const BOMB_FLASH_PERIOD = 32;
const TRAIL_FADE_TICKS  = 96;  // ticks to fade trail after nade lands (~1.5 s)

const TRAIL_COLORS = [
  'rgba(200,200,200,1)',  // 0: smoke (generic) — light gray
  'rgba(255,255,180,1)',  // 1: flash           — pale yellow
  'rgba(120,230,90,1)',   // 2: HE              — lime green
  'rgba(255,120,30,1)',   // 3: molotov         — orange
  'rgba(80,180,255,1)',   // 4: CT smoke        — blue
  'rgba(255,170,50,1)',   // 5: T smoke         — amber
];

const GREN_FEED_LABELS = ['Smoke', 'Flash', 'HE', 'Molotov', 'CT Smoke', 'T Smoke'];

// ── State ─────────────────────────────────────────────────────────────────────
let roundIdx = 0;
let framePos = 0;
let playing  = false;
let speed    = 1;
let showLower = false;
let statsOpen = false;
let lastTS   = null;
let rafID    = null;
let mousePos = null;
// Zoom / pan
let zoom = 1, panX = 0, panY = 0;
let dragging = false, dragStartX = 0, dragStartY = 0, dragPanX = 0, dragPanY = 0;

// ── Canvas ────────────────────────────────────────────────────────────────────
const canvas  = document.getElementById('canvas');
const ctx     = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

const radarImg      = new Image();
const radarLowerImg = new Image();
let radarReady      = false;
let radarLowerReady = false;

radarImg.onload = () => { radarReady = true; render(); };
radarImg.src = DEMO.radar;
if (DEMO.has_lower) {
  radarLowerImg.onload = () => { radarLowerReady = true; };
  radarLowerImg.src = DEMO.radar_lower;
}

// ── Init ──────────────────────────────────────────────────────────────────────
document.getElementById('map-name').textContent = DEMO.map;
document.getElementById('hdr-info').textContent =
  DEMO.rounds.length + ' rounds · ' + DEMO.players.length + ' players';
if (DEMO.has_lower) {
  document.getElementById('level-btn').style.display = 'block';
}
updateRoundLabel();
buildEventMarks(DEMO.rounds[roundIdx]);
resizeCanvas();
window.addEventListener('resize', resizeCanvas);
canvas.addEventListener('mousemove', onMouseMove);

// ── Resize ────────────────────────────────────────────────────────────────────
function resizeCanvas() {
  const wrap = document.getElementById('canvas-wrap');
  const sz = Math.min(wrap.clientWidth, wrap.clientHeight);
  canvas.width = sz;
  canvas.height = sz;
  clampPan();
  render();
}

// ── Coordinates ───────────────────────────────────────────────────────────────
function w2c(wx, wy) {
  const m = DEMO.meta, cs = canvas.width / RADAR_SIZE;
  const bx = ((wx - m.pos_x) / m.scale) * cs;
  const by = ((m.pos_y - wy) / m.scale) * cs;
  const cx = canvas.width / 2, cy = canvas.height / 2;
  return [(bx - cx) * zoom + cx + panX, (by - cy) * zoom + cy + panY];
}

function worldRToPx(worldR) {
  return zoom * (worldR / DEMO.meta.scale) * (canvas.width / RADAR_SIZE);
}

function clampPan() {
  const maxPan = canvas.width / 2 * (zoom - 1);
  panX = Math.max(-maxPan, Math.min(maxPan, panX));
  panY = Math.max(-maxPan, Math.min(maxPan, panY));
}

// ── Grenade in-flight position ────────────────────────────────────────────────
function interpTrailPos(tr, tick) {
  const pts = tr[TR_PTS];
  if (!pts || pts.length === 0) return null;
  const elapsed = tick - tr[TR_ST];
  if (elapsed < 0) return null;
  if (pts.length === 1 || elapsed <= pts[0][TR_PT_T])
    return [pts[0][TR_PT_X], pts[0][TR_PT_Y]];
  for (let i = 0; i < pts.length - 1; i++) {
    const t0 = pts[i][TR_PT_T], t1 = pts[i+1][TR_PT_T];
    if (elapsed >= t0 && elapsed <= t1) {
      const frac = t1 > t0 ? (elapsed - t0) / (t1 - t0) : 0;
      return [
        lerp(pts[i][TR_PT_X], pts[i+1][TR_PT_X], frac),
        lerp(pts[i][TR_PT_Y], pts[i+1][TR_PT_Y], frac),
      ];
    }
  }
  const last = pts[pts.length - 1];
  return [last[TR_PT_X], last[TR_PT_Y]];
}

// ── Interpolation ─────────────────────────────────────────────────────────────
function lerp(a, b, t) { return a + (b - a) * t; }

function interpPlayers(round, fp) {
  const fi = Math.floor(fp);
  const t  = fp - fi;
  const f0 = round.frames[Math.min(fi,     round.frames.length - 1)];
  const f1 = round.frames[Math.min(fi + 1, round.frames.length - 1)];
  if (!f0) return [];
  const map0 = {};
  for (const ps of f0.p) map0[ps[PS_IDX]] = ps;
  const src = (f1 && f1 !== f0) ? f1.p : f0.p;
  return src.map(ps1 => {
    const ps0 = map0[ps1[PS_IDX]];
    if (!ps0 || t === 0 || f0 === f1) return ps1;
    return [
      ps1[PS_IDX], ps1[PS_FLAGS], ps1[PS_HP],
      Math.round(lerp(ps0[PS_X], ps1[PS_X], t)),
      Math.round(lerp(ps0[PS_Y], ps1[PS_Y], t)),
      Math.round(lerp(ps0[PS_Z], ps1[PS_Z], t)),
      ps1[PS_YAW],
    ];
  });
}

function currentTick(round, fp) {
  const fi = Math.floor(fp);
  const t  = fp - fi;
  const f0 = round.frames[Math.min(fi,     round.frames.length - 1)];
  const f1 = round.frames[Math.min(fi + 1, round.frames.length - 1)];
  if (!f0) return 0;
  if (!f1 || f0 === f1) return f0.tick;
  return Math.round(lerp(f0.tick, f1.tick, t));
}

// ── Render ────────────────────────────────────────────────────────────────────
function render() {
  if (!radarReady) return;
  const sz = canvas.width;
  ctx.clearRect(0, 0, sz, sz);

  const img = (showLower && radarLowerReady) ? radarLowerImg : radarImg;
  const imgX = canvas.width / 2 * (1 - zoom) + panX;
  const imgY = canvas.height / 2 * (1 - zoom) + panY;
  ctx.drawImage(img, imgX, imgY, sz * zoom, sz * zoom);

  const round = DEMO.rounds[roundIdx];
  if (!round || round.frames.length === 0) return;

  const tick    = currentTick(round, framePos);
  const players = interpPlayers(round, framePos);
  const sc      = sz / RADAR_SIZE;
  const r       = Math.max(5, Math.round(PLAYER_R * sc));
  const dLen    = Math.round(DIR_LEN * sc);
  const lw      = Math.max(1.5, sc * 1.5);

  // ── Kill flashes ────────────────────────────────────────────────────────────
  for (const k of round.kills) {
    const age = tick - k[K_TICK];
    if (age < 0 || age >= KILL_FLASH_TICKS) continue;
    const alpha = 1 - age / KILL_FLASH_TICKS;
    const [vx, vy] = w2c(k[K_VX], k[K_VY]);
    const maxR = r * 3 * (1 - age / KILL_FLASH_TICKS * 0.5);
    const grad = ctx.createRadialGradient(vx, vy, 0, vx, vy, maxR);
    grad.addColorStop(0,   `rgba(255,80,80,${(alpha*0.9).toFixed(2)})`);
    grad.addColorStop(0.5, `rgba(255,150,50,${(alpha*0.5).toFixed(2)})`);
    grad.addColorStop(1,   'rgba(255,80,80,0)');
    ctx.beginPath();
    ctx.arc(vx, vy, maxR, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
  }


  // ── In-flight grenade projectiles ───────────────────────────────────────────
  for (const tr of (round.trails || [])) {
    const pts2 = tr[TR_PTS];
    if (!pts2 || pts2.length === 0) continue;
    const landTick2 = tr[TR_ST] + pts2[pts2.length - 1][TR_PT_T];
    if (tick < tr[TR_ST] || tick >= landTick2) continue;
    const pos = interpTrailPos(tr, tick);
    if (!pos) continue;
    const [gx, gy] = w2c(pos[0], pos[1]);
    const color = TRAIL_COLORS[tr[TR_TYPE]] || 'rgba(200,200,200,1)';
    const pr = Math.max(4, Math.round(5 * sc));
    const pulse = 0.5 + 0.5 * Math.sin(tick / 4 * Math.PI);
    ctx.save();
    // Pulsing ring
    ctx.globalAlpha = pulse * 0.7;
    ctx.beginPath();
    ctx.arc(gx, gy, pr * (1.6 + 0.6 * pulse), 0, Math.PI * 2);
    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(1.5, sc * 1.5);
    ctx.stroke();
    // Solid core dot
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.arc(gx, gy, pr, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
    ctx.lineWidth = Math.max(1, sc);
    ctx.stroke();
    ctx.restore();
  }

  // ── Active smokes ───────────────────────────────────────────────────────────
  const grenades = round.grenades || [];
  for (const g of grenades) {
    const gt = g[GR_TYPE];
    if (gt !== GT_SMOKE && gt !== GT_SMOKE_CT && gt !== GT_SMOKE_T) continue;
    if (tick < g[GR_ST] || tick > g[GR_ET]) continue;
    const [gx, gy] = w2c(g[GR_X], g[GR_Y]);
    const gr = worldRToPx(SMOKE_WORLD_R);
    let fillColor, strokeColor;
    if (gt === GT_SMOKE_CT) {
      fillColor = 'rgba(80,170,230,0.42)';
      strokeColor = 'rgba(100,200,255,0.72)';
    } else if (gt === GT_SMOKE_T) {
      fillColor = 'rgba(230,150,50,0.42)';
      strokeColor = 'rgba(255,175,80,0.72)';
    } else {
      fillColor = 'rgba(180,180,180,0.42)';
      strokeColor = 'rgba(210,210,210,0.72)';
    }
    ctx.beginPath();
    ctx.arc(gx, gy, gr, 0, Math.PI * 2);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = Math.max(1.5, lw);
    ctx.stroke();
  }

  // ── Molotovs ────────────────────────────────────────────────────────────────
  for (const g of grenades) {
    if (g[GR_TYPE] !== GT_MOLOTOV) continue;
    if (tick < g[GR_ST] || tick > g[GR_ET]) continue;
    const [gx, gy] = w2c(g[GR_X], g[GR_Y]);
    const gr = worldRToPx(MOLOTOV_WORLD_R);
    ctx.beginPath();
    ctx.arc(gx, gy, gr, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,90,20,0.38)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,140,40,0.75)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  // ── HE / Flash bursts ───────────────────────────────────────────────────────
  for (const g of grenades) {
    if (g[GR_TYPE] !== GT_HE && g[GR_TYPE] !== GT_FLASH) continue;
    const age = tick - g[GR_ST];
    if (age < 0 || age >= GREN_FADE_TICKS) continue;
    const t = age / GREN_FADE_TICKS;
    const alpha = 1 - t;
    const [gx, gy] = w2c(g[GR_X], g[GR_Y]);
    const maxR = r * 5 * (t * 0.75 + 0.15);
    const c = g[GR_TYPE] === GT_HE ? '255,180,30' : '240,240,255';
    // Bright radial fill
    const grad = ctx.createRadialGradient(gx, gy, 0, gx, gy, maxR);
    grad.addColorStop(0,   `rgba(${c},${(alpha * 0.95).toFixed(2)})`);
    grad.addColorStop(0.45, `rgba(${c},${(alpha * 0.55).toFixed(2)})`);
    grad.addColorStop(1,   `rgba(${c},0)`);
    ctx.beginPath();
    ctx.arc(gx, gy, maxR, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
    // Expanding ring stroke for extra clarity
    ctx.beginPath();
    ctx.arc(gx, gy, maxR * 0.88, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(${c},${(alpha * 0.8).toFixed(2)})`;
    ctx.lineWidth = Math.max(2, lw * 2);
    ctx.stroke();
  }

  // ── Active bomb ─────────────────────────────────────────────────────────────
  // act: 0=plant_begin, 1=planted, 2=defuse_begin, 3=defused, 4=exploded, 5=dropped, 6=pickup
  const bomb = round.bomb || [];
  let lastBomb = null;
  for (const ba of bomb) {
    if (ba[BA_TICK] <= tick) lastBomb = ba;
  }
  // Show bomb dot when: dropped(5), planting(0), planted(1), defusing(2), exploded(4)
  // Hide when: picked up (6) — carrier draws the icon on the player dot instead
  const bombVisible = lastBomb !== null && lastBomb[BA_ACT] !== 6 &&
    !(lastBomb[BA_ACT] === 1 && false); // always show planted
  if (bombVisible) {
    const act = lastBomb[BA_ACT];
    // color by state
    const bombColors = ['#ffd700','#ffd700','#4fc3f7','#2ea043','#f85149','#e6a817','#888'];
    const bombColor  = bombColors[act] || '#ffd700';
    {
      const [bx, by] = w2c(lastBomb[BA_X], lastBomb[BA_Y]);
      const br = Math.max(5, Math.round(7 * sc));
      ctx.beginPath();
      ctx.arc(bx, by, br, 0, Math.PI * 2);
      ctx.fillStyle = bombColor;
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx.lineWidth = Math.max(1, sc);
      ctx.stroke();
      ctx.font = `bold ${Math.max(8, Math.round(9 * sc))}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#000';
      ctx.fillText('B', bx, by);
      // Bomb timer countdown after planting (40 s = 2560 ticks)
      if (act === 1 || act === 2) {
        const remTicks = Math.max(0, lastBomb[BA_TICK] + 2560 - tick);
        const remSecs = (remTicks / 64).toFixed(1);
        ctx.fillStyle = act === 2 ? '#4fc3f7' : '#ffd700';
        ctx.font = `bold ${Math.max(7, Math.round(8 * sc))}px sans-serif`;
        ctx.fillText(remSecs, bx, by + br + Math.max(8, Math.round(10 * sc)));
      }
      ctx.textBaseline = 'alphabetic';
      ctx.textAlign = 'start';
    }
  }

  // ── Players ─────────────────────────────────────────────────────────────────
  const shots = round.shots || [];
  const hoverHits = [];

  for (const ps of players) {
    const team  = psTeam(ps);
    const alive = psAlive(ps);
    const onLower = DEMO.has_lower && ps[PS_Z] < DEMO.lower_z_max;
    if (DEMO.has_lower && onLower !== showLower) continue;

    const [cx, cy] = w2c(ps[PS_X], ps[PS_Y]);

    if (!alive) {
      ctx.strokeStyle = DEAD_COLOR;
      ctx.lineWidth   = lw;
      const d = r * 0.65;
      ctx.beginPath();
      ctx.moveTo(cx-d, cy-d); ctx.lineTo(cx+d, cy+d);
      ctx.moveTo(cx+d, cy-d); ctx.lineTo(cx-d, cy+d);
      ctx.stroke();
      continue;
    }

    // Direction indicator
    const yawRad = ps[PS_YAW] * Math.PI / 180;
    ctx.strokeStyle = 'rgba(255,255,255,0.65)';
    ctx.lineWidth   = lw;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(yawRad)*dLen, cy - Math.sin(yawRad)*dLen);
    ctx.stroke();

    // Circle
    const color = team === 'CT' ? CT_COLOR : T_COLOR;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fillStyle   = color;
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth   = Math.max(1, sc);
    ctx.stroke();

    // C4 carrier indicator
    if (psBomb(ps)) {
      const br2 = Math.max(4, Math.round(5 * sc));
      ctx.beginPath();
      ctx.arc(cx + r * 0.7, cy - r * 0.7, br2, 0, Math.PI * 2);
      ctx.fillStyle = '#ffd700';
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.font = `bold ${Math.max(6, Math.round(7 * sc))}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#000';
      ctx.fillText('C', cx + r * 0.7, cy - r * 0.7);
      ctx.textBaseline = 'alphabetic';
      ctx.textAlign = 'start';
    }

    // Shoot flash
    const recentShot = shots.find(
      s => s[SH_PIDX] === ps[PS_IDX] && tick - s[SH_TICK] >= 0 && tick - s[SH_TICK] < SHOOT_FLASH_TICKS
    );
    if (recentShot) {
      const age = tick - recentShot[SH_TICK];
      const alpha = 1 - age / SHOOT_FLASH_TICKS;
      const flashR = r * (1.3 + age / SHOOT_FLASH_TICKS * 1.2);
      ctx.beginPath();
      ctx.arc(cx, cy, flashR, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255,255,180,${alpha.toFixed(2)})`;
      ctx.lineWidth = Math.max(1, lw * 1.5);
      ctx.stroke();
    }

    // Name label
    const name = (DEMO.players[ps[PS_IDX]] || {}).name || '?';
    const label = name.length > 9 ? name.slice(0, 8) + '\u2026' : name;
    const fontSize = Math.max(9, Math.round(10 * sc));
    ctx.font = `bold ${fontSize}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    ctx.fillStyle = '#000';
    ctx.fillText(label, cx + 1, cy - r - 3);
    ctx.fillStyle = '#fff';
    ctx.fillText(label, cx, cy - r - 4);
    ctx.textAlign = 'start';

    if (mousePos) {
      const dx = mousePos.x - cx, dy = mousePos.y - cy;
      if (dx*dx + dy*dy <= (r+5)*(r+5)) hoverHits.push({ps, cx, cy});
    }
  }

  // Tooltip
  if (hoverHits.length > 0) {
    const {ps, cx, cy} = hoverHits[0];
    const info = DEMO.players[ps[PS_IDX]];
    tooltip.textContent = `${info ? info.name : '?'} · ${ps[PS_HP]} HP · ${psTeam(ps)}`;
    tooltip.style.display = 'block';
    tooltip.style.left = (cx + r + 4) + 'px';
    tooltip.style.top  = (cy - 10)    + 'px';
  } else if (mousePos) {
    tooltip.style.display = 'none';
  }

  // ── Alive counter ────────────────────────────────────────────────────────────
  let ctAlive = 0, tAlive = 0;
  for (const ps of players) {
    if (!psAlive(ps)) continue;
    if (psTeam(ps) === 'CT') ctAlive++; else tAlive++;
  }
  document.getElementById('ct-alive').textContent = ctAlive;
  document.getElementById('t-alive').textContent  = tAlive;

  // ── Round timer ───────────────────────────────────────────────────────────
  const rtEl = document.getElementById('round-timer');
  if (round.fe && tick >= round.fe) {
    const elapsed = Math.floor((tick - round.fe) / 64);
    const rem = Math.max(0, 115 - elapsed);
    rtEl.textContent = Math.floor(rem / 60) + ':' + String(rem % 60).padStart(2, '0');
  } else {
    rtEl.textContent = '1:55';
  }

  // ── C4 timer ──────────────────────────────────────────────────────────────
  const c4El = document.getElementById('c4-timer');
  if (lastBomb && (lastBomb[BA_ACT] === 1 || lastBomb[BA_ACT] === 2)) {
    const remTicks = Math.max(0, lastBomb[BA_TICK] + 2560 - tick);
    const remSecs  = remTicks / 64;
    let timeStr;
    if (remSecs < 10) {
      timeStr = remSecs.toFixed(1);
    } else {
      timeStr = Math.floor(remSecs / 60) + ':' + String(Math.floor(remSecs % 60)).padStart(2, '0');
    }
    c4El.textContent = 'C4 ' + timeStr;
    c4El.style.display = '';
    if (lastBomb[BA_ACT] === 2) {
      c4El.style.color = '#4fc3f7'; // defusing — blue
    } else if (remTicks < 320) {
      c4El.style.color = '#f85149'; // < 5 s — red
    } else {
      c4El.style.color = '#ffd700'; // yellow
    }
  } else {
    c4El.style.display = 'none';
  }

  updateKillFeed(round, tick);
  document.getElementById('tick-lbl').textContent = rtEl.textContent;
  const prog = round.frames.length > 1 ? framePos / (round.frames.length - 1) : 0;
  document.getElementById('timeline').value = Math.round(prog * 1000);
}

// ── Kill feed ─────────────────────────────────────────────────────────────────
// Active column (right):  kills · nade throws · bomb events
// Passive column (left):  hits received
let lastActiveSig = '';
let lastPassiveSig = '';

const BOMB_ACT_LABEL = ['Planting…','B Planted','Defusing…','B Defused','B Exploded','B Dropped','B Picked up'];

function buildFeedEl(entry, round) {
  const el = document.createElement('div');
  el.dataset.kt = entry.t;
  if (entry.type === 'bomb') {
    const ba = entry.data;
    el.className = 'kf-entry kf-bomb';
    el.innerHTML =
      `<div class="kf-row1">` +
      `<span class="kf-name-atk">${esc(BOMB_ACT_LABEL[ba[BA_ACT]] || 'Bomb event')}</span>` +
      (ba[BA_SITE] ? `<span class="kf-weapon">· Site ${esc(ba[BA_SITE])}</span>` : '') +
      `<span class="kf-time">${roundTimeFmt(round, ba[BA_TICK])}</span>` +
      `</div>`;
  } else if (entry.type === 'nade') {
    const tr = entry.data;
    const label = GREN_FEED_LABELS[tr[TR_TYPE]] || 'Nade';
    const throwerName = tr[TR_THROWER] >= 0 ? (DEMO.players[tr[TR_THROWER]] || {}).name : null;
    el.className = 'kf-entry kf-nade';
    el.innerHTML =
      `<div class="kf-row1">` +
      (throwerName ? `<span class="kf-name-atk">${esc(throwerName)}</span>` : '') +
      `<span class="kf-weapon">${esc(label)}</span>` +
      `<span class="kf-time">${roundTimeFmt(round, tr[TR_ST])}</span>` +
      `</div>`;
  } else if (entry.type === 'hit') {
    const h = entry.data;
    const atkName = (DEMO.players[h[HI_ATK]] || {}).name || '?';
    const vicName = (DEMO.players[h[HI_VIC]] || {}).name || '?';
    el.className = 'kf-entry kf-hit';
    el.innerHTML =
      `<div class="kf-row1">` +
      `<span class="kf-name-atk">${esc(atkName)}</span>` +
      `<span class="kf-weapon">${esc(h[HI_WEP])}</span>` +
      `<span class="kf-name-vic">${esc(vicName)}</span>` +
      `<span class="kf-dmg">${h[HI_DMG]}</span>` +
      `<span class="kf-time">${roundTimeFmt(round, h[HI_TICK])}</span>` +
      `</div>`;
  } else { // kill
    const k = entry.data;
    const atkName = (DEMO.players[k[K_ATK]] || {}).name || '?';
    const vicName = (DEMO.players[k[K_VIC]] || {}).name || '?';
    const atkTeam = getPlayerTeam(round, k[K_TICK], k[K_ATK]);
    el.className = 'kf-entry kf-' + atkTeam.toLowerCase();
    el.innerHTML =
      `<div class="kf-row1">` +
      `<span class="kf-name-atk">${esc(atkName)}</span>` +
      `<span class="kf-weapon">${esc(k[K_WEP])}</span>` +
      `<span class="kf-name-vic">${esc(vicName)}</span>` +
      (k[K_HS] ? '<span class="kf-hs">HS</span>' : '') +
      `<span class="kf-time">${roundTimeFmt(round, k[K_TICK])}</span>` +
      `</div>` +
      `<div class="kf-row2">` +
      (k[K_DMG] > 0 ? `<span class="kf-dmg">${k[K_DMG]} dmg</span>` : '') +
      `</div>`;
  }
  return el;
}

function updateKillFeed(round, tick) {
  const kills     = (round.kills  || []).filter(k  => k[K_TICK]  <= tick);
  const bombEvts  = (round.bomb   || []).filter(ba => ba[BA_TICK] <= tick && ba[BA_ACT] >= 1 && ba[BA_ACT] <= 5);
  const throwEvts = (round.trails || []).filter(tr => tr[TR_ST]  <= tick);
  const hitEvts   = (round.hits   || []).filter(h  => h[HI_TICK] <= tick);

  const active = [
    ...kills.map(k      => ({ t: k[K_TICK],   type: 'kill', data: k  })),
    ...bombEvts.map(ba  => ({ t: ba[BA_TICK], type: 'bomb', data: ba })),
    ...throwEvts.map(tr => ({ t: tr[TR_ST],   type: 'nade', data: tr })),
  ].sort((a, b) => a.t - b.t);

  const passive = hitEvts
    .map(h => ({ t: h[HI_TICK], type: 'hit', data: h }))
    .sort((a, b) => a.t - b.t);

  const activeSig  = active.map(e  => e.t + e.type).join(',');
  const passiveSig = passive.map(e => e.t + e.type).join(',');

  const activeEl  = document.getElementById('feed-active');
  const passiveEl = document.getElementById('feed-passive');

  if (activeSig !== lastActiveSig) {
    lastActiveSig = activeSig;
    activeEl.innerHTML = '';
    for (const entry of active.slice().reverse())
      activeEl.appendChild(buildFeedEl(entry, round));
  }
  if (passiveSig !== lastPassiveSig) {
    lastPassiveSig = passiveSig;
    passiveEl.innerHTML = '';
    for (const entry of passive.slice().reverse())
      passiveEl.appendChild(buildFeedEl(entry, round));
  }

  const fade = col => {
    for (const el of col.children) {
      const age = tick - parseInt(el.dataset.kt, 10);
      el.style.opacity = age < 192 ? 1 : Math.max(0.25, 1 - (age - 192) / 512);
    }
  };
  fade(activeEl);
  fade(passiveEl);
}

function getPlayerTeam(round, tick, pidx) {
  for (let i = round.frames.length - 1; i >= 0; i--) {
    if (round.frames[i].tick <= tick) {
      const ps = round.frames[i].p.find(p => p[PS_IDX] === pidx);
      if (ps) return psTeam(ps);
    }
  }
  return 'CT';
}

function esc(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// ── Timeline event markers ────────────────────────────────────────────────────
function buildEventMarks(round) {
  const container = document.getElementById('event-marks');
  container.innerHTML = '';
  if (!round || round.frames.length < 2) return;
  const startTick = round.frames[0].tick;
  const endTick   = round.frames[round.frames.length - 1].tick;
  const span = endTick - startTick;
  if (span <= 0) return;

  const pct = t => (Math.max(0, Math.min(1, (t - startTick) / span)) * 100).toFixed(2) + '%';

  // Kill markers
  for (const k of (round.kills || [])) {
    const team = getPlayerTeam(round, k[K_TICK], k[K_ATK]);
    const el = document.createElement('div');
    el.className = 'ev-mark';
    el.style.left = pct(k[K_TICK]);
    el.style.background = team === 'CT' ? CT_COLOR : T_COLOR;
    container.appendChild(el);
  }
  // Bomb markers
  const bombColors = ['#ffd700','#ffd700','#4fc3f7','#2ea043','#f85149'];
  for (const ba of (round.bomb || [])) {
    const el = document.createElement('div');
    el.className = 'ev-mark';
    el.style.left = pct(ba[BA_TICK]);
    el.style.width = '3px';
    el.style.background = bombColors[ba[BA_ACT]] || '#888';
    container.appendChild(el);
  }
}

// ── Stats panel ───────────────────────────────────────────────────────────────
function toggleStats() {
  statsOpen = !statsOpen;
  const panel = document.getElementById('stats-panel');
  const btn   = document.getElementById('stats-btn');
  panel.style.display = statsOpen ? 'flex' : 'none';
  btn.style.background = statsOpen ? '#1f6feb' : '#21262d';
  btn.style.borderColor = statsOpen ? '#1f6feb' : '#30363d';
  if (statsOpen) buildStatsTable();
  resizeCanvas(); // refit canvas after panel opens/closes
}

function buildStatsTable() {
  const round = DEMO.rounds[roundIdx];
  document.querySelector('.stats-hdr').textContent =
    round ? 'Round ' + round.n + ' Stats' : 'Stats';
  document.getElementById('stats-dmg-hdr').textContent = 'DMG';

  const kills  = round ? (round.kills  || []) : [];
  const dmgList = round ? (round.dmg   || []) : [];

  // Aggregate per-player stats for this round
  const pm = {}; // idx → {k, d, hs, dmg}
  const ensure = idx => { if (!pm[idx]) pm[idx] = {k:0, d:0, hs:0, dmg:0}; };
  for (const k of kills) {
    ensure(k[K_ATK]); ensure(k[K_VIC]);
    pm[k[K_ATK]].k++;
    if (k[K_HS]) pm[k[K_ATK]].hs++;
    pm[k[K_VIC]].d++;
  }
  for (const [idx, dmg] of dmgList) {
    ensure(idx);
    pm[idx].dmg += dmg;
  }

  const entries = Object.entries(pm)
    .map(([idx, s]) => ({ idx: +idx, s, name: (DEMO.players[+idx] || {}).name || '?' }))
    .sort((a, b) => b.s.k - a.s.k || b.s.dmg - a.s.dmg);

  const tbody = document.getElementById('stats-body');
  tbody.innerHTML = '';
  for (const { s, name } of entries) {
    const hsPct = s.k > 0 ? Math.round(s.hs / s.k * 100) : 0;
    const tr = document.createElement('tr');
    tr.innerHTML =
      `<td title="${esc(name)}">${esc(name)}</td>` +
      `<td style="font-weight:600">${s.k}</td>` +
      `<td>${s.d}</td>` +
      `<td>${hsPct}%</td>` +
      `<td>${s.dmg}</td>`;
    tbody.appendChild(tr);
  }
}

// ── Playback ──────────────────────────────────────────────────────────────────
function animFrame(ts) {
  if (!playing) { rafID = null; return; }
  if (lastTS !== null) {
    const dt = Math.min((ts - lastTS) / 1000, 0.033);
    framePos += dt * SAMPLE_FPS * speed;
    const round = DEMO.rounds[roundIdx];
    if (framePos >= round.frames.length - 1) {
      framePos = round.frames.length - 1;
      playing  = false;
      updatePlayBtn();
    }
  }
  lastTS = ts;
  render();
  if (playing) rafID = requestAnimationFrame(animFrame);
}

// ── Controls ──────────────────────────────────────────────────────────────────
function togglePlay() {
  playing = !playing;
  updatePlayBtn();
  if (playing) {
    const round = DEMO.rounds[roundIdx];
    if (framePos >= round.frames.length - 1) framePos = 0;
    lastTS = null;
    if (rafID) cancelAnimationFrame(rafID);
    rafID = requestAnimationFrame(animFrame);
  }
}

function updatePlayBtn() {
  document.getElementById('play-btn').innerHTML =
    playing ? '&#9646;&#9646; Pause' : '&#9654; Play';
}

function changeRound(delta) {
  const next = roundIdx + delta;
  if (next < 0 || next >= DEMO.rounds.length) return;
  roundIdx  = next;
  framePos  = 0;
  playing   = false;
  lastActiveSig = ''; lastPassiveSig = '';
  updatePlayBtn();
  updateRoundLabel();
  buildEventMarks(DEMO.rounds[roundIdx]);
  if (statsOpen) buildStatsTable();
  render();
}

function updateRoundLabel() {
  const r = DEMO.rounds[roundIdx];
  const suffix = r && r.w ? ' · ' + r.w : '';
  document.getElementById('round-lbl').textContent =
    'Round ' + (r ? r.n : roundIdx + 1) + '/' + DEMO.rounds.length + suffix;
  document.getElementById('ct-score').textContent = 'CT ' + (r ? r.cts : 0);
  document.getElementById('t-score').textContent  = 'T '  + (r ? r.ts  : 0);
}

function onScrub(val) {
  const round = DEMO.rounds[roundIdx];
  if (!round) return;
  framePos = (val / 1000) * (round.frames.length - 1);
  playing  = false;
  updatePlayBtn();
  render();
}

function setSpeed(s, btn) {
  speed = s;
  document.querySelectorAll('.spd-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
}

function toggleLevel() {
  showLower = !showLower;
  const btn = document.getElementById('level-btn');
  btn.textContent = showLower ? 'Lower' : 'Upper';
  btn.classList.toggle('lower', showLower);
  render();
}

function onMouseMove(e) {
  const rect = canvas.getBoundingClientRect();
  const scale = canvas.width / rect.width;
  if (dragging) {
    panX = dragPanX + (e.clientX - dragStartX) * scale;
    panY = dragPanY + (e.clientY - dragStartY) * scale;
    clampPan();
    if (!playing) render();
    return;
  }
  mousePos = {
    x: (e.clientX - rect.left) * scale,
    y: (e.clientY - rect.top)  * (canvas.height / rect.height),
  };
  if (!playing) render();
}

// ── Zoom / pan interactions ───────────────────────────────────────────────────
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const scale = canvas.width / rect.width;
  const mx = (e.clientX - rect.left) * scale;
  const my = (e.clientY - rect.top)  * (canvas.height / rect.height);
  const factor = e.deltaY < 0 ? 1.2 : 1 / 1.2;
  const newZoom = Math.max(1, Math.min(8, zoom * factor));
  if (newZoom !== zoom) {
    panX = mx - (mx - canvas.width  / 2 - panX) * (newZoom / zoom) - canvas.width  / 2;
    panY = my - (my - canvas.height / 2 - panY) * (newZoom / zoom) - canvas.height / 2;
    zoom = newZoom;
    clampPan();
    canvas.style.cursor = zoom > 1 ? 'grab' : 'crosshair';
    if (!playing) render();
  }
}, { passive: false });

canvas.addEventListener('mousedown', e => {
  if (e.button !== 0 || zoom <= 1) return;
  dragging = true;
  dragStartX = e.clientX; dragStartY = e.clientY;
  dragPanX = panX; dragPanY = panY;
  canvas.style.cursor = 'grabbing';
});

document.addEventListener('mouseup', () => {
  if (dragging) {
    dragging = false;
    canvas.style.cursor = zoom > 1 ? 'grab' : 'crosshair';
  }
});

canvas.addEventListener('dblclick', () => {
  zoom = 1; panX = 0; panY = 0;
  canvas.style.cursor = 'crosshair';
  render();
});

canvas.addEventListener('mouseleave', () => {
  mousePos = null;
  tooltip.style.display = 'none';
  if (dragging) { dragging = false; canvas.style.cursor = zoom > 1 ? 'grab' : 'crosshair'; }
});

document.addEventListener('visibilitychange', () => {
  if (!document.hidden) lastTS = null;
});

document.addEventListener('keydown', e => {
  if (e.target.tagName !== 'BODY') return;
  if (e.code === 'Space')      { e.preventDefault(); togglePlay(); }
  if (e.code === 'ArrowRight') { e.preventDefault(); changeRound(1); }
  if (e.code === 'ArrowLeft')  { e.preventDefault(); changeRound(-1); }
});
</script>
</body>
</html>
