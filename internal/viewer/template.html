<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CS2 Demo Viewer</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{background:#0d1117;color:#e6edf3;font-family:'Segoe UI',system-ui,sans-serif;display:flex;flex-direction:column;height:100vh;overflow:hidden;user-select:none}
#hdr{padding:8px 16px;background:#161b22;border-bottom:1px solid #30363d;display:flex;align-items:center;gap:12px;flex-shrink:0}
#hdr h1{font-size:15px;font-weight:600;color:#58a6ff}
#hdr-info{font-size:12px;color:#8b949e}
#main{flex:1;display:flex;overflow:hidden}
#canvas-wrap{flex:1;display:flex;align-items:center;justify-content:center;background:#0d1117;position:relative;overflow:hidden}
canvas{display:block;cursor:crosshair}
#killfeed{position:absolute;top:10px;right:10px;width:260px;pointer-events:none;display:flex;flex-direction:column;gap:4px}
.kf-entry{background:rgba(13,17,23,0.88);border-left:3px solid #444;border-radius:0 5px 5px 0;padding:5px 9px;font-size:12px;display:flex;flex-direction:column;gap:2px}
.kf-row1{display:flex;align-items:center;gap:6px}
.kf-row2{font-size:10px;color:#8b949e;display:flex;gap:6px}
.kf-ct{border-left-color:#4fc3f7}.kf-t{border-left-color:#ff9800}.kf-bomb{border-left-color:#ffd700}
.kf-name-atk{font-weight:700}.kf-name-vic{font-weight:700;color:#adbac7}
.kf-hs{color:#f85149;font-size:9px;background:#3d1a1a;border-radius:3px;padding:1px 3px}
.kf-weapon{color:#8b949e;font-size:11px}
.kf-dmg{color:#7ee787;font-size:10px;background:#0d2414;border-radius:3px;padding:1px 4px}
.kf-time{color:#6e7681;font-size:10px;margin-left:auto}
.kf-nade{border-left-color:#7ee787}
#level-btn{position:absolute;top:10px;left:10px;background:#21262d;border:1px solid #30363d;color:#e6edf3;padding:5px 10px;border-radius:4px;cursor:pointer;font-size:12px}
#level-btn:hover{background:#30363d}
#level-btn.lower{background:#2ea043;border-color:#2ea043}
#tooltip{position:absolute;background:rgba(13,17,23,0.92);border:1px solid #30363d;border-radius:4px;padding:4px 8px;font-size:11px;pointer-events:none;display:none;white-space:nowrap;z-index:10}
#controls{padding:8px 16px;background:#161b22;border-top:1px solid #30363d;display:flex;align-items:center;gap:10px;flex-shrink:0;min-height:46px}
.round-nav{display:flex;align-items:center;gap:4px}
.nav-btn{background:#21262d;border:1px solid #30363d;color:#e6edf3;width:26px;height:26px;border-radius:4px;cursor:pointer;font-size:13px;display:flex;align-items:center;justify-content:center}
.nav-btn:hover{background:#30363d}
#round-lbl{font-size:12px;min-width:80px;text-align:center;color:#e6edf3}
#play-btn{background:#238636;border:none;color:#fff;padding:5px 14px;border-radius:4px;cursor:pointer;font-size:13px;font-weight:500;min-width:70px;height:28px}
#play-btn:hover{background:#2ea043}
#timeline{width:100%;accent-color:#2ea043;cursor:pointer;margin:0}
.spd-btns{display:flex;gap:3px}
.spd-btn{background:#21262d;border:1px solid #30363d;color:#8b949e;padding:3px 7px;border-radius:4px;cursor:pointer;font-size:11px}
.spd-btn:hover{background:#30363d;color:#e6edf3}
.spd-btn.active{background:#1f6feb;border-color:#1f6feb;color:#fff}
#tick-lbl{font-size:11px;color:#8b949e;min-width:90px;text-align:right}
#event-marks{position:relative;height:4px;overflow:hidden;border-radius:2px}
.ev-mark{position:absolute;top:0;width:2px;height:100%;border-radius:1px;pointer-events:none;transform:translateX(-50%)}
/* Stats panel */
#stats-panel{width:260px;background:#161b22;border-left:1px solid #30363d;overflow-y:auto;flex-shrink:0;display:none;flex-direction:column}
#stats-panel table{width:100%;border-collapse:collapse;font-size:11px}
#stats-panel th{padding:6px 8px;color:#8b949e;font-weight:500;border-bottom:1px solid #30363d;text-align:right}
#stats-panel th:first-child{text-align:left}
#stats-panel td{padding:5px 8px;border-bottom:1px solid #21262d;text-align:right;white-space:nowrap}
#stats-panel td:first-child{text-align:left;max-width:120px;overflow:hidden;text-overflow:ellipsis}
#stats-panel tr:hover td{background:rgba(255,255,255,0.04)}
.stats-hdr{padding:8px 10px;font-size:11px;font-weight:600;color:#8b949e;letter-spacing:.05em;text-transform:uppercase;border-bottom:1px solid #30363d}
</style>
</head>
<body>
<div id="hdr">
  <h1 id="map-name">—</h1>
  <span id="hdr-info"></span>
  <div style="margin-left:auto;display:flex;align-items:center;gap:14px">
    <div id="alive-ctr" style="font-size:13px;font-weight:600;letter-spacing:.03em">
      <span id="ct-alive" style="color:#4fc3f7">5</span><span style="color:#555">v</span><span id="t-alive" style="color:#ff9800">5</span>
    </div>
    <button id="stats-btn" onclick="toggleStats()"
      style="background:#21262d;border:1px solid #30363d;color:#e6edf3;padding:4px 11px;border-radius:4px;cursor:pointer;font-size:12px">
      Stats
    </button>
    <div id="score" style="display:flex;gap:10px;font-size:13px;font-weight:600">
      <span id="ct-score" style="color:#4fc3f7">CT 0</span>
      <span style="color:#8b949e">—</span>
      <span id="t-score" style="color:#ff9800">T 0</span>
    </div>
  </div>
</div>
<div id="main">
  <div id="canvas-wrap">
    <canvas id="canvas"></canvas>
    <div id="killfeed"></div>
    <div id="level-btn" style="display:none" onclick="toggleLevel()">Upper</div>
    <div id="tooltip"></div>
  </div>
  <div id="stats-panel">
    <div class="stats-hdr">Match Stats</div>
    <table>
      <thead>
        <tr>
          <th>Player</th>
          <th>K</th><th>D</th><th>HS%</th><th id="stats-dmg-hdr">DMG</th>
        </tr>
      </thead>
      <tbody id="stats-body"></tbody>
    </table>
  </div>
</div>
<div id="controls">
  <div class="round-nav">
    <button class="nav-btn" onclick="changeRound(-1)">&#9664;</button>
    <span id="round-lbl">Round 1</span>
    <button class="nav-btn" onclick="changeRound(1)">&#9654;</button>
  </div>
  <button id="play-btn" onclick="togglePlay()">&#9654; Play</button>
  <div style="flex:1;display:flex;flex-direction:column;gap:2px;min-width:0">
    <input type="range" id="timeline" min="0" max="1000" value="0" oninput="onScrub(this.value)">
    <div id="event-marks"></div>
  </div>
  <div class="spd-btns">
    <button class="spd-btn" onclick="setSpeed(0.5,this)">0.5×</button>
    <button class="spd-btn active" onclick="setSpeed(1,this)">1×</button>
    <button class="spd-btn" onclick="setSpeed(2,this)">2×</button>
    <button class="spd-btn" onclick="setSpeed(4,this)">4×</button>
    <button class="spd-btn" onclick="setSpeed(8,this)">8×</button>
  </div>
  <span id="tick-lbl"></span>
</div>

<script>
const DEMO = /*INJECT_DATA*/;

// ── Data format helpers ───────────────────────────────────────────────────────
// PlayerState array: [idx, flags, hp, x, y, z, yaw]
const PS_IDX=0, PS_FLAGS=1, PS_HP=2, PS_X=3, PS_Y=4, PS_Z=5, PS_YAW=6;
function psTeam(ps)  { return (ps[PS_FLAGS] & 2) ? 'T' : 'CT'; }
function psAlive(ps) { return !(ps[PS_FLAGS] & 1); }
function psBomb(ps)  { return !!(ps[PS_FLAGS] & 4); }

// Round time: seconds elapsed from freeze-end tick
function roundTimeFmt(round, tick) {
  if (!round || !round.fe) return '';
  const secs = Math.max(0, Math.floor((tick - round.fe) / 64));
  return Math.floor(secs / 60) + ':' + String(secs % 60).padStart(2, '0');
}

// Kill array: [tick, atkIdx, vicIdx, weapon, hs(0/1), atkX, atkY, vicX, vicY, dmg]
const K_TICK=0,K_ATK=1,K_VIC=2,K_WEP=3,K_HS=4,K_AX=5,K_AY=6,K_VX=7,K_VY=8,K_DMG=9;

// BombAction array: [tick, action, x, y, site]
const BA_TICK=0, BA_ACT=1, BA_X=2, BA_Y=3, BA_SITE=4;

// Grenade array: [startTick, endTick, type, x, y]
const GR_ST=0, GR_ET=1, GR_TYPE=2, GR_X=3, GR_Y=4;
const GT_SMOKE=0, GT_FLASH=1, GT_HE=2, GT_MOLOTOV=3, GT_SMOKE_CT=4, GT_SMOKE_T=5;

// Shot array: [tick, playerIdx]
const SH_TICK=0, SH_PIDX=1;

// GrenadeTrail array: [startTick, endTick, type, [[tickOffset,x,y],...]]
const TR_ST=0, TR_ET=1, TR_TYPE=2, TR_PTS=3;
const TR_PT_T=0, TR_PT_X=1, TR_PT_Y=2;

// ── Constants ─────────────────────────────────────────────────────────────────
const RADAR_SIZE        = 1024;
const SAMPLE_FPS        = 4;
const CT_COLOR          = '#4fc3f7';
const T_COLOR           = '#ff9800';
const DEAD_COLOR        = '#555';
const PLAYER_R          = 8;
const DIR_LEN           = 18;
const KILL_FLASH_TICKS  = 48;
const KILL_FEED_MAX     = 8;
const SMOKE_WORLD_R     = 170;
const MOLOTOV_WORLD_R   = 120;
const GREN_FADE_TICKS   = 64;
const SHOOT_FLASH_TICKS = 12;
const BOMB_FLASH_PERIOD = 32;
const TRAIL_FADE_TICKS  = 96;  // ticks to fade trail after nade lands (~1.5 s)

const TRAIL_COLORS = [
  'rgba(200,200,200,1)',  // 0: smoke (generic) — light gray
  'rgba(255,255,180,1)',  // 1: flash           — pale yellow
  'rgba(120,230,90,1)',   // 2: HE              — lime green
  'rgba(255,120,30,1)',   // 3: molotov         — orange
  'rgba(80,180,255,1)',   // 4: CT smoke        — blue
  'rgba(255,170,50,1)',   // 5: T smoke         — amber
];

const GREN_FEED_LABELS = ['Smoke', 'Flash', 'HE', 'Molotov', 'CT Smoke', 'T Smoke'];

// ── State ─────────────────────────────────────────────────────────────────────
let roundIdx = 0;
let framePos = 0;
let playing  = false;
let speed    = 1;
let showLower = false;
let statsOpen = false;
let lastTS   = null;
let rafID    = null;
let mousePos = null;
// Zoom / pan
let zoom = 1, panX = 0, panY = 0;
let dragging = false, dragStartX = 0, dragStartY = 0, dragPanX = 0, dragPanY = 0;

// ── Canvas ────────────────────────────────────────────────────────────────────
const canvas  = document.getElementById('canvas');
const ctx     = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

const radarImg      = new Image();
const radarLowerImg = new Image();
let radarReady      = false;
let radarLowerReady = false;

radarImg.onload = () => { radarReady = true; render(); };
radarImg.src = DEMO.radar;
if (DEMO.has_lower) {
  radarLowerImg.onload = () => { radarLowerReady = true; };
  radarLowerImg.src = DEMO.radar_lower;
}

// ── Init ──────────────────────────────────────────────────────────────────────
document.getElementById('map-name').textContent = DEMO.map;
document.getElementById('hdr-info').textContent =
  DEMO.rounds.length + ' rounds · ' + DEMO.players.length + ' players';
if (DEMO.has_lower) {
  document.getElementById('level-btn').style.display = 'block';
}
updateRoundLabel();
buildEventMarks(DEMO.rounds[roundIdx]);
resizeCanvas();
window.addEventListener('resize', resizeCanvas);
canvas.addEventListener('mousemove', onMouseMove);

// ── Resize ────────────────────────────────────────────────────────────────────
function resizeCanvas() {
  const wrap = document.getElementById('canvas-wrap');
  const sz = Math.min(wrap.clientWidth, wrap.clientHeight);
  canvas.width = sz;
  canvas.height = sz;
  clampPan();
  render();
}

// ── Coordinates ───────────────────────────────────────────────────────────────
function w2c(wx, wy) {
  const m = DEMO.meta, cs = canvas.width / RADAR_SIZE;
  const bx = ((wx - m.pos_x) / m.scale) * cs;
  const by = ((m.pos_y - wy) / m.scale) * cs;
  const cx = canvas.width / 2, cy = canvas.height / 2;
  return [(bx - cx) * zoom + cx + panX, (by - cy) * zoom + cy + panY];
}

function worldRToPx(worldR) {
  return zoom * (worldR / DEMO.meta.scale) * (canvas.width / RADAR_SIZE);
}

function clampPan() {
  const maxPan = canvas.width / 2 * (zoom - 1);
  panX = Math.max(-maxPan, Math.min(maxPan, panX));
  panY = Math.max(-maxPan, Math.min(maxPan, panY));
}

// ── Interpolation ─────────────────────────────────────────────────────────────
function lerp(a, b, t) { return a + (b - a) * t; }

function interpPlayers(round, fp) {
  const fi = Math.floor(fp);
  const t  = fp - fi;
  const f0 = round.frames[Math.min(fi,     round.frames.length - 1)];
  const f1 = round.frames[Math.min(fi + 1, round.frames.length - 1)];
  if (!f0) return [];
  const map0 = {};
  for (const ps of f0.p) map0[ps[PS_IDX]] = ps;
  const src = (f1 && f1 !== f0) ? f1.p : f0.p;
  return src.map(ps1 => {
    const ps0 = map0[ps1[PS_IDX]];
    if (!ps0 || t === 0 || f0 === f1) return ps1;
    return [
      ps1[PS_IDX], ps1[PS_FLAGS], ps1[PS_HP],
      Math.round(lerp(ps0[PS_X], ps1[PS_X], t)),
      Math.round(lerp(ps0[PS_Y], ps1[PS_Y], t)),
      Math.round(lerp(ps0[PS_Z], ps1[PS_Z], t)),
      ps1[PS_YAW],
    ];
  });
}

function currentTick(round, fp) {
  const fi = Math.floor(fp);
  const t  = fp - fi;
  const f0 = round.frames[Math.min(fi,     round.frames.length - 1)];
  const f1 = round.frames[Math.min(fi + 1, round.frames.length - 1)];
  if (!f0) return 0;
  if (!f1 || f0 === f1) return f0.tick;
  return Math.round(lerp(f0.tick, f1.tick, t));
}

// ── Render ────────────────────────────────────────────────────────────────────
function render() {
  if (!radarReady) return;
  const sz = canvas.width;
  ctx.clearRect(0, 0, sz, sz);

  const img = (showLower && radarLowerReady) ? radarLowerImg : radarImg;
  const imgX = canvas.width / 2 * (1 - zoom) + panX;
  const imgY = canvas.height / 2 * (1 - zoom) + panY;
  ctx.drawImage(img, imgX, imgY, sz * zoom, sz * zoom);

  const round = DEMO.rounds[roundIdx];
  if (!round || round.frames.length === 0) return;

  const tick    = currentTick(round, framePos);
  const players = interpPlayers(round, framePos);
  const sc      = sz / RADAR_SIZE;
  const r       = Math.max(5, Math.round(PLAYER_R * sc));
  const dLen    = Math.round(DIR_LEN * sc);
  const lw      = Math.max(1.5, sc * 1.5);

  // ── Kill flashes ────────────────────────────────────────────────────────────
  for (const k of round.kills) {
    const age = tick - k[K_TICK];
    if (age < 0 || age >= KILL_FLASH_TICKS) continue;
    const alpha = 1 - age / KILL_FLASH_TICKS;
    const [vx, vy] = w2c(k[K_VX], k[K_VY]);
    const maxR = r * 3 * (1 - age / KILL_FLASH_TICKS * 0.5);
    const grad = ctx.createRadialGradient(vx, vy, 0, vx, vy, maxR);
    grad.addColorStop(0,   `rgba(255,80,80,${(alpha*0.9).toFixed(2)})`);
    grad.addColorStop(0.5, `rgba(255,150,50,${(alpha*0.5).toFixed(2)})`);
    grad.addColorStop(1,   'rgba(255,80,80,0)');
    ctx.beginPath();
    ctx.arc(vx, vy, maxR, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
  }

  // ── Grenade throw arcs ──────────────────────────────────────────────────────
  for (const tr of (round.trails || [])) {
    const fadeTick = tr[TR_ET] + TRAIL_FADE_TICKS;
    if (tick < tr[TR_ST] || tick > fadeTick) continue;
    const pts = tr[TR_PTS];
    if (!pts || pts.length < 2) continue;

    const inFlight = tick <= tr[TR_ET];
    const elapsed  = tick - tr[TR_ST];

    // Determine last visible point index
    let lastIdx = pts.length - 1;
    if (inFlight) {
      lastIdx = -1;
      for (let i = 0; i < pts.length; i++) {
        if (pts[i][TR_PT_T] <= elapsed) lastIdx = i; else break;
      }
      if (lastIdx < 0) continue;
    }

    const fadeAlpha = inFlight ? 0.85 : 0.85 * (1 - (tick - tr[TR_ET]) / TRAIL_FADE_TICKS);
    if (fadeAlpha <= 0.01) continue;

    const trailColor = TRAIL_COLORS[tr[TR_TYPE]] || 'rgba(200,200,200,1)';
    ctx.save();
    ctx.globalAlpha = fadeAlpha;
    ctx.setLineDash([Math.max(2, sc * 3), Math.max(1.5, sc * 2)]);
    ctx.lineWidth   = Math.max(1.2, sc * 2);
    ctx.strokeStyle = trailColor;
    ctx.beginPath();
    const [sx0, sy0] = w2c(pts[0][TR_PT_X], pts[0][TR_PT_Y]);
    ctx.moveTo(sx0, sy0);
    for (let i = 1; i <= lastIdx; i++) {
      const [px, py] = w2c(pts[i][TR_PT_X], pts[i][TR_PT_Y]);
      ctx.lineTo(px, py);
    }
    ctx.stroke();
    ctx.restore();
  }

  // ── Active smokes ───────────────────────────────────────────────────────────
  const grenades = round.grenades || [];
  for (const g of grenades) {
    const gt = g[GR_TYPE];
    if (gt !== GT_SMOKE && gt !== GT_SMOKE_CT && gt !== GT_SMOKE_T) continue;
    if (tick < g[GR_ST] || tick > g[GR_ET]) continue;
    const [gx, gy] = w2c(g[GR_X], g[GR_Y]);
    const gr = worldRToPx(SMOKE_WORLD_R);
    let fillColor, strokeColor;
    if (gt === GT_SMOKE_CT) {
      fillColor = 'rgba(80,170,230,0.42)';
      strokeColor = 'rgba(100,200,255,0.72)';
    } else if (gt === GT_SMOKE_T) {
      fillColor = 'rgba(230,150,50,0.42)';
      strokeColor = 'rgba(255,175,80,0.72)';
    } else {
      fillColor = 'rgba(180,180,180,0.42)';
      strokeColor = 'rgba(210,210,210,0.72)';
    }
    ctx.beginPath();
    ctx.arc(gx, gy, gr, 0, Math.PI * 2);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = Math.max(1.5, lw);
    ctx.stroke();
  }

  // ── Molotovs ────────────────────────────────────────────────────────────────
  for (const g of grenades) {
    if (g[GR_TYPE] !== GT_MOLOTOV) continue;
    if (tick < g[GR_ST] || tick > g[GR_ET]) continue;
    const [gx, gy] = w2c(g[GR_X], g[GR_Y]);
    const gr = worldRToPx(MOLOTOV_WORLD_R);
    ctx.beginPath();
    ctx.arc(gx, gy, gr, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,90,20,0.38)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,140,40,0.75)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  // ── HE / Flash bursts ───────────────────────────────────────────────────────
  for (const g of grenades) {
    if (g[GR_TYPE] !== GT_HE && g[GR_TYPE] !== GT_FLASH) continue;
    const age = tick - g[GR_ST];
    if (age < 0 || age >= GREN_FADE_TICKS) continue;
    const t = age / GREN_FADE_TICKS;
    const alpha = 1 - t;
    const [gx, gy] = w2c(g[GR_X], g[GR_Y]);
    const maxR = r * 5 * (t * 0.75 + 0.15);
    const c = g[GR_TYPE] === GT_HE ? '255,180,30' : '240,240,255';
    // Bright radial fill
    const grad = ctx.createRadialGradient(gx, gy, 0, gx, gy, maxR);
    grad.addColorStop(0,   `rgba(${c},${(alpha * 0.95).toFixed(2)})`);
    grad.addColorStop(0.45, `rgba(${c},${(alpha * 0.55).toFixed(2)})`);
    grad.addColorStop(1,   `rgba(${c},0)`);
    ctx.beginPath();
    ctx.arc(gx, gy, maxR, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
    // Expanding ring stroke for extra clarity
    ctx.beginPath();
    ctx.arc(gx, gy, maxR * 0.88, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(${c},${(alpha * 0.8).toFixed(2)})`;
    ctx.lineWidth = Math.max(2, lw * 2);
    ctx.stroke();
  }

  // ── Active bomb ─────────────────────────────────────────────────────────────
  // act: 0=plant_begin, 1=planted, 2=defuse_begin, 3=defused, 4=exploded, 5=dropped, 6=pickup
  const bomb = round.bomb || [];
  let lastBomb = null;
  for (const ba of bomb) {
    if (ba[BA_TICK] <= tick) lastBomb = ba;
  }
  // Show bomb dot when: dropped(5), planting(0), planted(1), defusing(2), exploded(4)
  // Hide when: picked up (6) — carrier draws the icon on the player dot instead
  const bombVisible = lastBomb !== null && lastBomb[BA_ACT] !== 6 &&
    !(lastBomb[BA_ACT] === 1 && false); // always show planted
  if (bombVisible) {
    const act = lastBomb[BA_ACT];
    // color by state
    const bombColors = ['#ffd700','#ffd700','#4fc3f7','#2ea043','#f85149','#e6a817','#888'];
    const bombBlink  = [true,    false,    true,     false,    false,    true,     false];
    const bombColor  = bombColors[act] || '#ffd700';
    const blink      = bombBlink[act];
    const bombVis    = !blink || Math.floor(tick / BOMB_FLASH_PERIOD) % 2 === 0;
    if (bombVis) {
      const [bx, by] = w2c(lastBomb[BA_X], lastBomb[BA_Y]);
      const br = Math.max(5, Math.round(7 * sc));
      ctx.beginPath();
      ctx.arc(bx, by, br, 0, Math.PI * 2);
      ctx.fillStyle = bombColor;
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx.lineWidth = Math.max(1, sc);
      ctx.stroke();
      ctx.font = `bold ${Math.max(8, Math.round(9 * sc))}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#000';
      ctx.fillText('B', bx, by);
      // Bomb timer countdown after planting (40 s = 2560 ticks)
      if (act === 1 || act === 2) {
        const remTicks = Math.max(0, lastBomb[BA_TICK] + 2560 - tick);
        const remSecs = (remTicks / 64).toFixed(1);
        ctx.fillStyle = act === 2 ? '#4fc3f7' : '#ffd700';
        ctx.font = `bold ${Math.max(7, Math.round(8 * sc))}px sans-serif`;
        ctx.fillText(remSecs, bx, by + br + Math.max(8, Math.round(10 * sc)));
      }
      ctx.textBaseline = 'alphabetic';
      ctx.textAlign = 'start';
    }
  }

  // ── Players ─────────────────────────────────────────────────────────────────
  const shots = round.shots || [];
  const hoverHits = [];

  for (const ps of players) {
    const team  = psTeam(ps);
    const alive = psAlive(ps);
    const onLower = DEMO.has_lower && ps[PS_Z] < DEMO.lower_z_max;
    if (DEMO.has_lower && onLower !== showLower) continue;

    const [cx, cy] = w2c(ps[PS_X], ps[PS_Y]);

    if (!alive) {
      ctx.strokeStyle = DEAD_COLOR;
      ctx.lineWidth   = lw;
      const d = r * 0.65;
      ctx.beginPath();
      ctx.moveTo(cx-d, cy-d); ctx.lineTo(cx+d, cy+d);
      ctx.moveTo(cx+d, cy-d); ctx.lineTo(cx-d, cy+d);
      ctx.stroke();
      continue;
    }

    // Direction indicator
    const yawRad = ps[PS_YAW] * Math.PI / 180;
    ctx.strokeStyle = 'rgba(255,255,255,0.65)';
    ctx.lineWidth   = lw;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(yawRad)*dLen, cy - Math.sin(yawRad)*dLen);
    ctx.stroke();

    // Circle
    const color = team === 'CT' ? CT_COLOR : T_COLOR;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fillStyle   = color;
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth   = Math.max(1, sc);
    ctx.stroke();

    // C4 carrier indicator
    if (psBomb(ps)) {
      const br2 = Math.max(4, Math.round(5 * sc));
      ctx.beginPath();
      ctx.arc(cx + r * 0.7, cy - r * 0.7, br2, 0, Math.PI * 2);
      ctx.fillStyle = '#ffd700';
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.font = `bold ${Math.max(6, Math.round(7 * sc))}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#000';
      ctx.fillText('C', cx + r * 0.7, cy - r * 0.7);
      ctx.textBaseline = 'alphabetic';
      ctx.textAlign = 'start';
    }

    // Shoot flash
    const recentShot = shots.find(
      s => s[SH_PIDX] === ps[PS_IDX] && tick - s[SH_TICK] >= 0 && tick - s[SH_TICK] < SHOOT_FLASH_TICKS
    );
    if (recentShot) {
      const age = tick - recentShot[SH_TICK];
      const alpha = 1 - age / SHOOT_FLASH_TICKS;
      const flashR = r * (1.3 + age / SHOOT_FLASH_TICKS * 1.2);
      ctx.beginPath();
      ctx.arc(cx, cy, flashR, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255,255,180,${alpha.toFixed(2)})`;
      ctx.lineWidth = Math.max(1, lw * 1.5);
      ctx.stroke();
    }

    // Name label
    const name = (DEMO.players[ps[PS_IDX]] || {}).name || '?';
    const label = name.length > 9 ? name.slice(0, 8) + '\u2026' : name;
    const fontSize = Math.max(9, Math.round(10 * sc));
    ctx.font = `bold ${fontSize}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    ctx.fillStyle = '#000';
    ctx.fillText(label, cx + 1, cy - r - 3);
    ctx.fillStyle = '#fff';
    ctx.fillText(label, cx, cy - r - 4);
    ctx.textAlign = 'start';

    if (mousePos) {
      const dx = mousePos.x - cx, dy = mousePos.y - cy;
      if (dx*dx + dy*dy <= (r+5)*(r+5)) hoverHits.push({ps, cx, cy});
    }
  }

  // Tooltip
  if (hoverHits.length > 0) {
    const {ps, cx, cy} = hoverHits[0];
    const info = DEMO.players[ps[PS_IDX]];
    tooltip.textContent = `${info ? info.name : '?'} · ${ps[PS_HP]} HP · ${psTeam(ps)}`;
    tooltip.style.display = 'block';
    tooltip.style.left = (cx + r + 4) + 'px';
    tooltip.style.top  = (cy - 10)    + 'px';
  } else if (mousePos) {
    tooltip.style.display = 'none';
  }

  // ── Alive counter ────────────────────────────────────────────────────────────
  let ctAlive = 0, tAlive = 0;
  for (const ps of players) {
    if (!psAlive(ps)) continue;
    if (psTeam(ps) === 'CT') ctAlive++; else tAlive++;
  }
  document.getElementById('ct-alive').textContent = ctAlive;
  document.getElementById('t-alive').textContent  = tAlive;

  updateKillFeed(round, tick);
  document.getElementById('tick-lbl').textContent = 'tick ' + tick;
  const prog = round.frames.length > 1 ? framePos / (round.frames.length - 1) : 0;
  document.getElementById('timeline').value = Math.round(prog * 1000);
}

// ── Kill feed / bomb feed ─────────────────────────────────────────────────────
let lastFeedSig = '';

const BOMB_ACT_LABEL = ['Planting…','B Planted','Defusing…','B Defused','B Exploded','B Dropped','B Picked up'];

function updateKillFeed(round, tick) {
  // Merge kills + bomb events + nade events visible at current tick, sorted by tick.
  const kills = (round.kills || []).filter(k => k[K_TICK] <= tick);
  const bombEvts = (round.bomb || []).filter(ba => ba[BA_TICK] <= tick &&
    ba[BA_ACT] >= 1 && ba[BA_ACT] <= 5); // skip plant_begin(0) and pickup(6)
  const nadeEvts = (round.grenades || []).filter(g => g[GR_ST] <= tick);

  const merged = [
    ...kills.map(k    => ({ t: k[K_TICK],   type: 'kill', data: k  })),
    ...bombEvts.map(ba => ({ t: ba[BA_TICK], type: 'bomb', data: ba })),
    ...nadeEvts.map(g  => ({ t: g[GR_ST],   type: 'nade', data: g  })),
  ].sort((a, b) => a.t - b.t).slice(-KILL_FEED_MAX);

  const sig = merged.map(e => e.t + e.type).join(',');
  const feed = document.getElementById('killfeed');
  if (sig !== lastFeedSig) {
    lastFeedSig = sig;
    feed.innerHTML = '';
    for (const entry of merged.slice().reverse()) {
      const el = document.createElement('div');
      el.dataset.kt = entry.t;
      if (entry.type === 'bomb') {
        const ba = entry.data;
        el.className = 'kf-entry kf-bomb';
        el.innerHTML =
          `<div class="kf-row1">` +
          `<span class="kf-name-atk">${esc(BOMB_ACT_LABEL[ba[BA_ACT]] || 'Bomb event')}</span>` +
          (ba[BA_SITE] ? `<span class="kf-weapon">· Site ${esc(ba[BA_SITE])}</span>` : '') +
          `<span class="kf-time">${roundTimeFmt(round, ba[BA_TICK])}</span>` +
          `</div>`;
      } else if (entry.type === 'nade') {
        const g = entry.data;
        const label = GREN_FEED_LABELS[g[GR_TYPE]] || 'Nade';
        el.className = 'kf-entry kf-nade';
        el.innerHTML =
          `<div class="kf-row1">` +
          `<span class="kf-name-atk">${esc(label)}</span>` +
          `<span class="kf-time">${roundTimeFmt(round, g[GR_ST])}</span>` +
          `</div>`;
      } else {
        const k = entry.data;
        const atkName = (DEMO.players[k[K_ATK]] || {}).name || '?';
        const vicName = (DEMO.players[k[K_VIC]] || {}).name || '?';
        const atkTeam = getPlayerTeam(round, k[K_TICK], k[K_ATK]);
        el.className = 'kf-entry kf-' + atkTeam.toLowerCase();
        el.innerHTML =
          `<div class="kf-row1">` +
          `<span class="kf-name-atk">${esc(atkName)}</span>` +
          `<span class="kf-weapon">${esc(k[K_WEP])}</span>` +
          `<span class="kf-name-vic">${esc(vicName)}</span>` +
          (k[K_HS] ? '<span class="kf-hs">HS</span>' : '') +
          `<span class="kf-time">${roundTimeFmt(round, k[K_TICK])}</span>` +
          `</div>` +
          `<div class="kf-row2">` +
          (k[K_DMG] > 0 ? `<span class="kf-dmg">${k[K_DMG]} dmg</span>` : '') +
          `</div>`;
      }
      feed.appendChild(el);
    }
  }
  for (const el of feed.children) {
    const age = tick - parseInt(el.dataset.kt, 10);
    el.style.opacity = age < 192 ? 1 : Math.max(0.25, 1 - (age - 192) / 512);
  }
}

function getPlayerTeam(round, tick, pidx) {
  for (let i = round.frames.length - 1; i >= 0; i--) {
    if (round.frames[i].tick <= tick) {
      const ps = round.frames[i].p.find(p => p[PS_IDX] === pidx);
      if (ps) return psTeam(ps);
    }
  }
  return 'CT';
}

function esc(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// ── Timeline event markers ────────────────────────────────────────────────────
function buildEventMarks(round) {
  const container = document.getElementById('event-marks');
  container.innerHTML = '';
  if (!round || round.frames.length < 2) return;
  const startTick = round.frames[0].tick;
  const endTick   = round.frames[round.frames.length - 1].tick;
  const span = endTick - startTick;
  if (span <= 0) return;

  const pct = t => (Math.max(0, Math.min(1, (t - startTick) / span)) * 100).toFixed(2) + '%';

  // Kill markers
  for (const k of (round.kills || [])) {
    const team = getPlayerTeam(round, k[K_TICK], k[K_ATK]);
    const el = document.createElement('div');
    el.className = 'ev-mark';
    el.style.left = pct(k[K_TICK]);
    el.style.background = team === 'CT' ? CT_COLOR : T_COLOR;
    container.appendChild(el);
  }
  // Bomb markers
  const bombColors = ['#ffd700','#ffd700','#4fc3f7','#2ea043','#f85149'];
  for (const ba of (round.bomb || [])) {
    const el = document.createElement('div');
    el.className = 'ev-mark';
    el.style.left = pct(ba[BA_TICK]);
    el.style.width = '3px';
    el.style.background = bombColors[ba[BA_ACT]] || '#888';
    container.appendChild(el);
  }
}

// ── Stats panel ───────────────────────────────────────────────────────────────
function toggleStats() {
  statsOpen = !statsOpen;
  const panel = document.getElementById('stats-panel');
  const btn   = document.getElementById('stats-btn');
  panel.style.display = statsOpen ? 'flex' : 'none';
  btn.style.background = statsOpen ? '#1f6feb' : '#21262d';
  btn.style.borderColor = statsOpen ? '#1f6feb' : '#30363d';
  if (statsOpen) buildStatsTable();
  resizeCanvas(); // refit canvas after panel opens/closes
}

function buildStatsTable() {
  const round = DEMO.rounds[roundIdx];
  document.querySelector('.stats-hdr').textContent =
    round ? 'Round ' + round.n + ' Stats' : 'Stats';
  document.getElementById('stats-dmg-hdr').textContent = 'DMG';

  const kills  = round ? (round.kills  || []) : [];
  const dmgList = round ? (round.dmg   || []) : [];

  // Aggregate per-player stats for this round
  const pm = {}; // idx → {k, d, hs, dmg}
  const ensure = idx => { if (!pm[idx]) pm[idx] = {k:0, d:0, hs:0, dmg:0}; };
  for (const k of kills) {
    ensure(k[K_ATK]); ensure(k[K_VIC]);
    pm[k[K_ATK]].k++;
    if (k[K_HS]) pm[k[K_ATK]].hs++;
    pm[k[K_VIC]].d++;
  }
  for (const [idx, dmg] of dmgList) {
    ensure(idx);
    pm[idx].dmg += dmg;
  }

  const entries = Object.entries(pm)
    .map(([idx, s]) => ({ idx: +idx, s, name: (DEMO.players[+idx] || {}).name || '?' }))
    .sort((a, b) => b.s.k - a.s.k || b.s.dmg - a.s.dmg);

  const tbody = document.getElementById('stats-body');
  tbody.innerHTML = '';
  for (const { s, name } of entries) {
    const hsPct = s.k > 0 ? Math.round(s.hs / s.k * 100) : 0;
    const tr = document.createElement('tr');
    tr.innerHTML =
      `<td title="${esc(name)}">${esc(name)}</td>` +
      `<td style="font-weight:600">${s.k}</td>` +
      `<td>${s.d}</td>` +
      `<td>${hsPct}%</td>` +
      `<td>${s.dmg}</td>`;
    tbody.appendChild(tr);
  }
}

// ── Playback ──────────────────────────────────────────────────────────────────
function animFrame(ts) {
  if (!playing) { rafID = null; return; }
  if (lastTS !== null) {
    const dt = Math.min((ts - lastTS) / 1000, 0.033);
    framePos += dt * SAMPLE_FPS * speed;
    const round = DEMO.rounds[roundIdx];
    if (framePos >= round.frames.length - 1) {
      framePos = round.frames.length - 1;
      playing  = false;
      updatePlayBtn();
    }
  }
  lastTS = ts;
  render();
  if (playing) rafID = requestAnimationFrame(animFrame);
}

// ── Controls ──────────────────────────────────────────────────────────────────
function togglePlay() {
  playing = !playing;
  updatePlayBtn();
  if (playing) {
    const round = DEMO.rounds[roundIdx];
    if (framePos >= round.frames.length - 1) framePos = 0;
    lastTS = null;
    if (rafID) cancelAnimationFrame(rafID);
    rafID = requestAnimationFrame(animFrame);
  }
}

function updatePlayBtn() {
  document.getElementById('play-btn').innerHTML =
    playing ? '&#9646;&#9646; Pause' : '&#9654; Play';
}

function changeRound(delta) {
  const next = roundIdx + delta;
  if (next < 0 || next >= DEMO.rounds.length) return;
  roundIdx  = next;
  framePos  = 0;
  playing   = false;
  lastFeedSig = '';
  updatePlayBtn();
  updateRoundLabel();
  buildEventMarks(DEMO.rounds[roundIdx]);
  if (statsOpen) buildStatsTable();
  render();
}

function updateRoundLabel() {
  const r = DEMO.rounds[roundIdx];
  const suffix = r && r.w ? ' · ' + r.w : '';
  document.getElementById('round-lbl').textContent =
    'Round ' + (r ? r.n : roundIdx + 1) + '/' + DEMO.rounds.length + suffix;
  document.getElementById('ct-score').textContent = 'CT ' + (r ? r.cts : 0);
  document.getElementById('t-score').textContent  = 'T '  + (r ? r.ts  : 0);
}

function onScrub(val) {
  const round = DEMO.rounds[roundIdx];
  if (!round) return;
  framePos = (val / 1000) * (round.frames.length - 1);
  playing  = false;
  updatePlayBtn();
  render();
}

function setSpeed(s, btn) {
  speed = s;
  document.querySelectorAll('.spd-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
}

function toggleLevel() {
  showLower = !showLower;
  const btn = document.getElementById('level-btn');
  btn.textContent = showLower ? 'Lower' : 'Upper';
  btn.classList.toggle('lower', showLower);
  render();
}

function onMouseMove(e) {
  const rect = canvas.getBoundingClientRect();
  const scale = canvas.width / rect.width;
  if (dragging) {
    panX = dragPanX + (e.clientX - dragStartX) * scale;
    panY = dragPanY + (e.clientY - dragStartY) * scale;
    clampPan();
    if (!playing) render();
    return;
  }
  mousePos = {
    x: (e.clientX - rect.left) * scale,
    y: (e.clientY - rect.top)  * (canvas.height / rect.height),
  };
  if (!playing) render();
}

// ── Zoom / pan interactions ───────────────────────────────────────────────────
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const scale = canvas.width / rect.width;
  const mx = (e.clientX - rect.left) * scale;
  const my = (e.clientY - rect.top)  * (canvas.height / rect.height);
  const factor = e.deltaY < 0 ? 1.2 : 1 / 1.2;
  const newZoom = Math.max(1, Math.min(8, zoom * factor));
  if (newZoom !== zoom) {
    panX = mx - (mx - canvas.width  / 2 - panX) * (newZoom / zoom) - canvas.width  / 2;
    panY = my - (my - canvas.height / 2 - panY) * (newZoom / zoom) - canvas.height / 2;
    zoom = newZoom;
    clampPan();
    canvas.style.cursor = zoom > 1 ? 'grab' : 'crosshair';
    if (!playing) render();
  }
}, { passive: false });

canvas.addEventListener('mousedown', e => {
  if (e.button !== 0 || zoom <= 1) return;
  dragging = true;
  dragStartX = e.clientX; dragStartY = e.clientY;
  dragPanX = panX; dragPanY = panY;
  canvas.style.cursor = 'grabbing';
});

document.addEventListener('mouseup', () => {
  if (dragging) {
    dragging = false;
    canvas.style.cursor = zoom > 1 ? 'grab' : 'crosshair';
  }
});

canvas.addEventListener('dblclick', () => {
  zoom = 1; panX = 0; panY = 0;
  canvas.style.cursor = 'crosshair';
  render();
});

canvas.addEventListener('mouseleave', () => {
  mousePos = null;
  tooltip.style.display = 'none';
  if (dragging) { dragging = false; canvas.style.cursor = zoom > 1 ? 'grab' : 'crosshair'; }
});

document.addEventListener('visibilitychange', () => {
  if (!document.hidden) lastTS = null;
});

document.addEventListener('keydown', e => {
  if (e.target.tagName !== 'BODY') return;
  if (e.code === 'Space')      { e.preventDefault(); togglePlay(); }
  if (e.code === 'ArrowRight') { e.preventDefault(); changeRound(1); }
  if (e.code === 'ArrowLeft')  { e.preventDefault(); changeRound(-1); }
});
</script>
</body>
</html>
